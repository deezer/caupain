package com.deezer.caupain.resolver

import com.deezer.caupain.internal.processRequest
import com.deezer.caupain.model.Dependency
import com.deezer.caupain.model.DependencyUpdateResult
import com.deezer.caupain.model.GradleDependencyVersion
import com.deezer.caupain.model.Logger
import com.deezer.caupain.model.versionCatalog.Version
import com.deezer.caupain.model.vuln.Coordinates
import com.deezer.caupain.model.vuln.Vulnerability
import com.deezer.caupain.model.vuln.VulnerabilityResponse
import io.ktor.client.HttpClient
import io.ktor.client.request.basicAuth
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.http.ContentType
import io.ktor.http.contentType
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.withContext

@OptIn(ExperimentalCoroutinesApi::class)
internal class VulnerabilityResolver(
    private val httpClient: HttpClient,
    private val ioDispatcher: CoroutineDispatcher,
    private val logger: Logger,
    private val username: String?,
    private val apiToken: String?,
) {
    constructor(
        httpClient: HttpClient,
        ioDispatcher: CoroutineDispatcher,
        logger: Logger
    ) : this(httpClient, ioDispatcher, logger, null, null)

    suspend fun getFixedVulnerabilities(
        updateResults: List<DependencyUpdateResult>,
    ): Map<String, List<Vulnerability>> {
        val dependencyInfos = updateResults.mapNotNull { result ->
            if (
                result.dependency is Dependency.Library
                && result.currentVersion is Version.Simple
                && result.currentVersion.value is GradleDependencyVersion.Static
            ) {
                DependencyInfo(
                    dependencyKey = result.dependencyKey,
                    dependency = result.dependency,
                    currentVersion = result.currentVersion.value.exactVersion.toString(),
                    updatedVersion = result.updatedVersion.exactVersion.toString(),
                )
            } else {
                null
            }
        }
        if (dependencyInfos.isEmpty()) return emptyMap()

        val coordinates = dependencyInfos.flatMap { info ->
            listOf(info.currentCoordinates, info.updatedCoordinates)
        }
        val vulnsByCoordinates = coroutineScope {
            coordinates
                .chunked(MAX_DEPENDENCIES_PER_REQUEST)
                .map { coordinates ->
                    async {
                        withContext(ioDispatcher) {
                            requestVulnerabilities(coordinates)
                        }
                    }
                }
                .toList()
                .awaitAll()
                .flatten()
                .associate { it.coordinates to it.vulnerabilities }
        }

        return if (vulnsByCoordinates.isEmpty()) {
            emptyMap()
        } else {
            buildMap {
                for (info in dependencyInfos) {
                    val currentVulns = vulnsByCoordinates[info.currentCoordinates].orEmpty()
                    val updatedVulnsId = vulnsByCoordinates[info.updatedCoordinates]
                        .orEmpty()
                        .mapTo(hashSetOf()) { it.id }
                    if (currentVulns.isNotEmpty()) {
                        val fixedVulns = currentVulns.filter { it.id !in updatedVulnsId }
                        if (fixedVulns.isNotEmpty()) put(info.dependencyKey, fixedVulns)
                    }
                }
            }
        }
    }

    private suspend fun requestVulnerabilities(coordinates: List<String>): List<VulnerabilityResponse> {
        return httpClient.processRequest<List<VulnerabilityResponse>>(
            default = emptyList(),
            onRecoverableError = { error ->
                logger.error(
                    "Unable to fetch vulnerabilities",
                    error
                )
            }
        ) {
            post(OSSINDEX_COMPONENT_REPORT_URL) {
                if (username != null && apiToken != null) {
                    basicAuth(username, apiToken)
                }
                setBody(Coordinates(coordinates))
                contentType(ContentType.Application.Json)
            }
        }
    }

    private data class DependencyInfo(
        val dependencyKey: String,
        val dependency: Dependency.Library,
        val currentVersion: String,
        val updatedVersion: String,
    ) {
        val currentCoordinates =
            "pkg:maven/${dependency.group}/${dependency.name}@${currentVersion}"
        val updatedCoordinates =
            "pkg:maven/${dependency.group}/${dependency.name}@${updatedVersion}"
    }

    companion object {
        private const val MAX_DEPENDENCIES_PER_REQUEST = 128
        private const val OSSINDEX_COMPONENT_REPORT_URL =
            "https://ossindex.sonatype.org/api/v3/component-report"
    }
}
